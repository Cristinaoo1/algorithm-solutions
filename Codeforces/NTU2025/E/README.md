# CF1430C Numbers on Whiteboard

*************************
## 题目描述

在黑板上写有数字 $1, 2, 3, \dots, n$（每个整数从 $1$ 到 $n$ 各出现一次）。每次操作，你可以从黑板上任意擦去两个数字 $a$ 和 $b$，并写上一个新的整数 $\lceil \frac{a + b}{2} \rceil$（即 $\frac{a + b}{2}$ 向上取整）。

你需要进行 $n-1$ 次这样的操作，使得最后黑板上剩下的那个数字尽可能小。

例如，如果 $n = 4$，最优的操作过程如下：

1. 选择 $a = 4$ 和 $b = 2$，新数字为 $3$，黑板上变为 $[1, 3, 3]$；
2. 选择 $a = 3$ 和 $b = 3$，新数字为 $3$，黑板上变为 $[1, 3]$；
3. 选择 $a = 1$ 和 $b = 3$，新数字为 $2$，黑板上变为 $[2]$。

显然，经过 $n-1$ 次操作后，黑板上只会剩下一个数字。你的目标是让这个数字尽可能小。

*************************
## 输入格式

第一行包含一个整数 $t$($1 \le t \le 1000$)，表示测试用例的数量。

每个测试用例的唯一一行包含一个整数 $n$($2 \le n \le 2 \times 10^5$)，表示初始时黑板上的整数个数。

保证所有测试用例中 $n$ 的总和不超过 $2 \times 10^5$。

*************************
## 输出格式

对于每个测试用例，第一行输出经过 $n-1$ 次操作后黑板上可能剩下的最小数字。接下来的 $n-1$ 行，每行输出两个整数 $a$ 和 $b$，表示每次操作中被选择并擦去的两个数字。

*************************
## 思路
也是简单模拟一下，就会发现无论你怎么选择a和b,结果都是2；
既然如此，我就选择方便点的，我就从后往前选a和b。
带大家模拟一下：
```
n=10,为偶数：
1 2 3 4 5 6 7 8 9 10      找规律
1 2 3 4 5 6 7 8 10    （选择 9，10）第一次：(n-1，n)
第二次之后选的a和b相差都是2
1 2 3 4 5 6 7 9       （选择 8，10）第二次：(n-2，n)
1 2 3 4 5 6 8         （选择 7，9） 第三次：(n-3，n-1)
1 2 3 4 5 7           （选择 6，8） 第四次：(n-4，n-2)
......                 ...
...                    ...
```

```
n=5,为奇数：
1 2 3 4 5
1 2 3 5      （选择4，5）第一次：(n-1，n)

1 2 4        （选择3，5）第二次：(n-2，n)
1 3          （选择2，4）第三次：(n-3，n-1)
2            （选择1，3）第四次：(n-4，n-2)
```
所以无论n为奇偶都是一个做法

## AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t;
    cin >> t;
    while (t--)
    {
        int n;
        cin >> n;

        cout << 2 << '\n';
        if (n == 2)
        {
            cout << "1 2\n";
            continue;
        }

        cout << n << ' ' << n - 1 << '\n';
        for (int i = n - 1; i > 1; --i)
        {
            cout << i + 1 << ' ' << i - 1 << '\n';
        }
    }

    return 0;
}

```