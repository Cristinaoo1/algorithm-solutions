# CF1789B Serval and Inversion Magic

*********
## 题目描述

Serval 有一个只包含 $0$ 和 $1$ 的字符串 $s$，长度为 $n$。第 $i$ 个字符记为 $s_i$，其中 $1\leq i\leq n$。

Serval 可以对字符串 $s$ 执行如下操作，称为“反转魔法”：

- 选择一个区间 $[l, r]$ ($1\leq l\leq r\leq n$)。对于 $l\leq i\leq r$，如果 $s_i$ 是 $0$，则将其变为 $1$；如果 $s_i$ 是 $1$，则将其变为 $0$。

例如，若 $s=010100$，选择区间 $[2,5]$，则执行反转魔法后 $s$ 变为 $001010$。

Serval 想要通过恰好执行一次反转魔法，使得 $s$ 变为回文串。请你帮他判断是否有可能。

一个字符串是回文串，当且仅当它正着读和反着读都相同。例如,$010010$ 是回文串，但 $10111$ 不是。

*********
## 输入格式

每组测试数据包含多组测试用例。第一行包含一个整数 $t$($1\leq t\leq 10^4$)，表示测试用例的数量。

每组测试用例的第一行包含一个整数 $n$($2\leq n\leq 10^5$)，表示字符串 $s$ 的长度。

第二行包含一个长度为 $n$ 的二进制字符串 $s$，仅包含字符 $0$ 和 $1$。

保证所有测试用例中 $n$ 的总和不超过 $2\cdot 10^5$。

*********
## 输出格式

对于每组测试用例，如果可以通过恰好一次反转魔法使 $s$ 变为回文串，输出 Yes，否则输出 No。

你可以用任意大小写形式输出 Yes 和 No（例如 yEs、yes、Yes、YES 都会被识别为肯定回答）。

*********
## 思路
由于讨论回文性我会将下面所有示例字符串以|分成两半
##### 1.先思考我的[l,r]区间有哪些可能呢？

>第一种：区间跨左右不对称
<ins>1011|11</ins>10
如果想要这种区间反转后回文，至少要先保证<ins>11|11</ins>回文
如果<ins>11|11</ins>是回文的，区间完全可以缩小为
<ins>10</ins>11|1110
即可以归纳为第三种

>第二种：区间跨左右对称
10<ins>11111</ins>01
这种一定本来就是回文串，直接YES

>第三种：区间在一侧
<ins>11011</ins>|11101
从外层向内，由内层向外，如果本来就满足回文，区间完全可以缩小为
1<ins>10</ins>11|11101

##### 2.从区间的分析已经得到了本题算法
> (1)本来就是回文串，直接YES
(2)从外层向内，由内层向外,找最小区间
(3)最小区间反转后回文即为YES
(4)否则为NO

************
### 时间复杂度 O(n)

*********
## AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin >> t;
    while (t--)
    {
        int n;
        cin >> n;
        string s;
        cin >> s;
        if (n == 1)
        {
            cout << "Yes\n";
            continue;
        }
        int i = 0, j = n - 1, x = floor((n - 1) / 2), y = n / 2;
        while (i < j && s[i] == s[j])
        {
            i++, j--;
        }
        while (i <= x && y <= j && s[x] == s[y])
        {
            x--, y++;
        }
        if (i == x + 1)
        {
            cout << "Yes\n";
            continue;
        }
        else
        {
            while (((s[i] - '0') == 1 - (s[j] - '0')) && (i <= x))
            {
                i++, j--;
            }
            if (i == x + 1)
            {
                cout << "Yes\n";
            }
            else
            {
                cout << "No\n";
            }
        }
    }
}
```


