# CF1206B Make Product Equal One

*********
## 题目描述

给你一个有 $n$ 个数的数组。你可以用 $x$(x为任意正整数) 的代价将数组中的任意一个数增加或减少 $x$ ，你可以重复多次此操作。现在需要你用若干次操作使得 $a_1·a_2·...·a_n = 1$ (数组的乘积为1)。

比如，当 $n=3$ 和数组为 [**1,-3,0**] 时，我们最少需要花费 $3$ 的代价：用 $2$ 的代价把 -$3$ 增加到 -$1$ ，再用 $1$ 的代价把 $0$ 减少到 -$1$ ，数组就变成了 [**1,-1,-1**] ，然后 $1·(-1)·(-1)=1$ 。

现在询问最少需要花费多少的代价使得数组的乘积为 $1$ 。

*********
## 输入格式

输入共两行。

第一行输入一个数 $n$ ，表示数组的数字个数。

第二行输入 $n$ 个数 $a_i$ ，表示该数组。

*********
## 输出格式

输出一个数，表示使得数组的乘积为 $1$ 的最少的花费。

*********
## 思路
显然，乘积为1即全为1和-1，且-1的个数为偶数。

> 第一步：小于-1的化为-1，大于1的化为1，0先不变

> 第二步：第一步之后如果-1的个数为奇数且0的个数为0，那么就有一个-1要化为1；如果有0，就可以补一个0为-1使-1的个数为偶数。

**********
## AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int t;
    cin >> t;
    int s = 0;
    int zero = 0;
    long long ans = 0;

    for (int i = 0; i < t; i++)
    {
        int x;
        cin >> x;
        if (x < 0)
        {
            s++;
            ans += -1 - x;
        }
        else if (x == 0)
        {
            zero++;
            ans += 1;
        }
        else
        {
            ans += x - 1;
        }
    }

    if (s % 2 != 0 && zero == 0)
    {
        ans += 2;
    }

    cout << ans;
    return 0;
}
```
